<?php
/**
 * Class LogSms
 * @property int           $id
 * @property String        $fromNumber
 * @property String        $toNumber
 * @property int           $clientId
 * @property String        $text
 * @property int           $createdBy
 * @property String        $created
 * @property String        $sid
 * @property double        $price
 * @property String        $price_unit
 * @property String        $uri
 * @property String        $status
 * @property String        $type
 * @property Int           $readBy
 * @property String        $readAt
 * @property String        $isRead
 *
 * @property Appointment[] $appointment
 * @property Client        $client
 * @property User          $reader
 * @property User          $sender
 *
 */

class Sms extends CActiveRecord
{

	const TYPE_OUTGOING = 'outgoing';
	const TYPE_INCOMING = 'incoming';
	const READ_UNREAD   = 'unread';
	const READ_READ     = 'read'; // the most stupid name ever;

	/**
	 * @var int used to search for read messages
	 */

	/**
	 * @param string $className
	 * @return static
	 */
	public static function model($className = __CLASS__)
	{
		return parent::model($className); // TODO: Change the autogenerated stub
	}

	public function tableName()
	{
		return 'log_sms';
	}

	public function attributeLabels()
	{
		return array(
			'id'         => 'id',
			'fromNumber' => 'From number',
			'toNumber'   => 'To number',
			'ClientId'   => 'Client Id',
			'text'       => 'Text',
			'createdBy'  => 'Created By',
			'created'    => 'Created',
			'sid'        => 'SID',
			'price'      => 'Price',
			'price_unit' => 'Price Unit',
			'uri'        => 'URI',
			'status'     => 'Status',
			'readBy'     => 'Read by',
			'readAt'     => 'Read at',
			'read'       => 'Read',
		);
	}

	public function rules()
	{
		return [
			['isRead', 'safe', 'on' => 'search'],
		];
	}

	public function relations()
	{
		return [
			'appointment' => [self::MANY_MANY, 'Appointment', 'link_appointment_to_sms(smsId, appointmentId)'],
			'client'      => [self::BELONGS_TO, 'Client', 'clientId', 'together' => true],
			'reader'      => [self::BELONGS_TO, 'User', 'readBy'],
			'sender'      => [self::BELONGS_TO, 'User', 'createdBy'],
		];
	}

	public function search()
	{
		$criteria = $this->getDbCriteria();
		$criteria->compare('isRead', $this->isRead);

		return new CActiveDataProvider($this, CMap::mergeArray(Yii::app()->params['CActiveDataProvider'], array('criteria' => $criteria)));
	}

	/**
	 *
	 */
	public function send()
	{
		if (!$this->isNewRecord) {
			throw new Exception('cannot send message that is already sent');
		}

		$twilio          = new Services_Twilio(Yii::app()->params['twilio']['sid'], Yii::app()->params['twilio']['token']);
		$message         = $twilio->account->sms_messages->create(
														 Yii::app()->params['twilio']['number'],
														 isset(Yii::app()->params['twilio']['test_run']) && Yii::app()->params['twilio']['test_run'] ? Yii::app()->params['twilio']['test_number'] : $this->prepareNumber($this->toNumber),
														 $this->text
		);
		$this->createdBy = Yii::app()->user->id;
		$this->created   = date("Y-m-d H:i:s");

		$this->fromNumber = $message->from;
		$this->toNumber   = $message->to;
		$this->sid        = $message->sid;
		$this->status     = $message->status;
		$this->uri        = $message->uri;
		$this->price      = $message->price;
		$this->price_unit = $message->price_unit;
		$this->type       = self::TYPE_OUTGOING;

		$this->save(false);
	}

	public function receive($data)
	{
		if (!$this->isNewRecord) {
			throw new Exception('cannot receive message twice');
		}
		$this->createdBy = Yii::app()->user->id;
		$this->created   = date("Y-m-d H:i:s");

		$this->fromNumber = $data['From'];
		$this->toNumber   = $data['To'];
		$this->sid        = $data['MessageSid'];
		$this->text       = $data['Body'];
		$this->status     = $data['SmsStatus'];
		$this->type       = self::TYPE_INCOMING;
		$this->save(false);
	}

	/**
	 * @param $number
	 * @return mixed
	 * @throws Exception
	 */
	private function prepareNumber($number)
	{
		$number = preg_replace('/[^0-9]/', '', $number);
		if (preg_match('/^07/', $number)) { // starts with 07
			$number = preg_replace('/^07/', '447', $number);
		}
		if (!preg_match('/^447/', $number) || strlen($number) !== 12) { // doesn't start with 07 nor 447
			throw new Exception('phonenumber is not a valid mobile phone number');
		}
		return $number;
	}

	/**
	 * @return static
	 */
	public function latestTextToClient()
	{
		$criteria        = $this->getDbCriteria();
		$criteria->limit = 1;
		$criteria->order = 'created DESC';
		$criteria->compare('type', self::TYPE_OUTGOING);
		return $this->find($criteria);
	}

	/**
	 * @return CActiveDataProvider
	 */
	public function incoming()
	{
		$criteria = $this->getDbCriteria();
		$criteria->compare('type', self::TYPE_INCOMING);
		$criteria->with = ['client'];
		return $this->search();
	}

	/**
	 * @param $userId
	 * @throws LogicException
	 */
	public function markRead($userId)
	{
		if ($this->isRead()) {
			throw new LogicException('Message is already marked as read');
		}
		$this->readBy = $userId;
		$this->readAt = date('Y-m-d H:i:s');
		$this->isRead = self::READ_READ;
		$this->save(false);
	}

	/**
	 * @return bool
	 */
	public function isRead()
	{
		return $this->isRead !== self::READ_UNREAD;
	}
}
